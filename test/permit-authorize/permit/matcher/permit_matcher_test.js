// Generated by LiveScript 1.2.0
(function(){
  var requires, expect, Matcher, pm, ctx, ar;
  requires = require('../../../../requires');
  requires.test('test_setup');
  expect = require('chai').expect;
  Matcher = requires.permit('matcher').PermitMatcher;
  pm = function(ctx, ar, debug){
    debug == null && (debug = true);
    return new Matcher(ctx, ar);
  };
  ctx = {};
  ar = {};
  describe('PermitMatcher', function(){
    before(function(){});
    describe('create', function(){
      describe('invalid ar', function(){
        return specify('throws', function(){
          return expect(function(){
            return pm({}, void 8);
          }).to['throw'];
        });
      });
      return describe('valid', function(){
        return specify('is ok', function(){
          return expect(function(){
            return pm({}, {
              x: 2
            });
          }).to.not['throw'];
        });
      });
    });
    return context('valid MC', function(){
      var pmatcher;
      before(function(){
        ctx.article = {
          subject: {
            title: 'Hey ho!',
            _clazz: 'Article'
          }
        };
        ctx.compile = {
          matches: {
            matchOn: {
              includes: {
                subject: ['Article']
              }
            }
          },
          subject: {
            title: 'Hey ho!',
            _clazz: 'Article'
          }
        };
        ar.article = {
          subject: 'Article'
        };
        ar.finger = {
          subject: 'Article',
          fingerprint: function(){
            return 'my ass xx';
          }
        };
        return pmatcher = pm(ctx.article, ar.article);
      });
      specify('matchers are empty', function(){
        return pmatcher.matchers.should.eql({});
      });
      specify('match is by default true since matchers are by default disabled', function(){
        return pmatcher.match().should.eql(true);
      });
      specify('Permit matchers are by default disabled', function(){
        return Permit.matchersEnabled.should.eql(false);
      });
      describe('matcher', function(){
        var incMatcher, key;
        before(function(){
          key = 'includes';
          return incMatcher = pmatcher.matcher(key);
        });
        specify('is a ContextMatcher', function(){
          return incMatcher.constructor.displayName.should.eql('ContextMatcher');
        });
        specify('has context', function(){
          return incMatcher.context.should.eql(ctx.article);
        });
        specify('has ar', function(){
          return incMatcher.accessRequest.should.eql(ar.article);
        });
        return specify('has key', function(){
          return incMatcher.key.should.eql(key);
        });
      });
      context("they're not matching", function(){
        var res;
        return describe.only('match', function(){
          before(function(){
            res = pmatcher.match();
            return console.log(res);
          });
          return specify('should not match', function(){
            return res.should.eql(true);
          });
        });
      });
      return context("they're matching", function(){
        xdescribe('match-compiled', function(){
          var mc;
          beforeEach(function(){
            pmatcher = pm(ctx.compile, ar);
            return mc = pmatcher.matchCompiled();
          });
          return specify('matches compiled', function(){
            return expect(mc).to.eql(true);
          });
        });
        xdescribe('include', function(){
          var inc;
          beforeEach(function(){
            pmatcher = pm(ctx, ar);
            return inc = pmatcher.include();
          });
          return specify('matches include', function(){
            return expect(inc).to.eql(true);
          });
        });
        return xdescribe('exclude', function(){
          var excl;
          beforeEach(function(){
            pmatcher = pm(ctx, ar);
            return excl = pmatcher.exclude();
          });
          return specify('matches exclude', function(){
            return expect(excl).to.eql(true);
          });
        });
      });
    });
  });
}).call(this);
