// Generated by LiveScript 1.2.0
(function(){
  var requires, Matcher, Permit, setup, createUser, createMatcher;
  requires = require('../../../../requires');
  requires.test('test_setup');
  Matcher = requires.permit('matcher').ExcludeMatcher;
  Permit = requires.lib('permit').Permit;
  setup = requires.fix('permits').setup;
  createUser = requires.fac('create-user');
  createMatcher = function(ctx, ar, debug){
    debug == null && (debug = true);
    return new Matcher(ctx, ar, debug);
  };
  describe('PermitMatcher', function(){
    var matcher, book, users, permits, requests, matching, noneMatching;
    users = {};
    permits = {};
    requests = {};
    matching = {};
    noneMatching = {};
    before(function(){
      users.kris = createUser.kris();
      users.emily = createUser.emily();
      requests.user = {
        user: users.kris
      };
      return permits.user = setup.userPermit();
    });
    describe('exclude', function(){
      describe('excludes user.name: kris', function(){
        beforeEach(function(){
          permits.user.excludes = {
            user: users.kris
          };
          return matcher = createMatcher(permits.user, requests.user);
        });
        return specify('matches access-request on excludes intersect', function(){
          return matcher.exclude().should.be['true'];
        });
      });
      describe('excludes empty {}', function(){
        beforeEach(function(){
          permits.user.excludes = {};
          return matcher = createMatcher(permits.user, requests.user);
        });
        return specify('matches access-request since empty excludes always intersect', function(){
          return matcher.exclude().should.be['true'];
        });
      });
      return describe('excludes other user', function(){
        beforeEach(function(){
          permits.user.excludes = {
            user: users.emily
          };
          return matcher = createMatcher(permits.user, requests.user);
        });
        return specify('does NOT match access-request since NO excludes intersect', function(){
          return matcher.exclude().should.be['false'];
        });
      });
    });
    return xdescribe('custom-ex-match', function(){
      var subject, matcher, book, users, permits, requests, matching, noneMatching;
      users = {};
      permits = {};
      requests = {};
      matching = {};
      noneMatching = {};
      requests.admin = {
        user: {
          role: 'admin'
        }
      };
      requests.ctx = {
        ctx: void 8
      };
      beforeEach(function(){
        Permit.registry.clearAll();
        permits.exUser = setup.exUserPermit();
        matching.matcher = createMatcher(permits.user, requests.admin);
        return noneMatching.matcher = createMatcher(permits.exUser, requests.ctx);
      });
      specify('matches access-request using permit.ex-match', function(){
        return matching.matcher.match().should.be['true'];
      });
      specify('does NOT match access-request since permit.match does NOT match', function(){
        return noneMatching.matcher.match().should.be['false'];
      });
      return describe('invalid ex-match method', function(){
        before(function(){
          return permits.invalidExUser = setup.invalidExUser();
        });
        return specify('should throw error', function(){
          return function(){
            return noneMatching.matcher.customExMatch;
          }.should['throw'];
        });
      });
    });
  });
}).call(this);
