// Generated by LiveScript 1.2.0
(function(){
  var requires, Book, User, Permit, permitFor, PermitMatcher, PermitRegistry, setup, createUser, createRequest, createPermit;
  requires = require('../../../../../requires');
  requires.test('test_setup');
  Book = requires.fix('book');
  User = requires.fix('user');
  Permit = requires.lib('permit');
  permitFor = requires.permit('factory').permitFor;
  PermitMatcher = requires.permit('matcher').UsePermitMatcher;
  PermitRegistry = requires.permit('registry').PermitRegistry;
  setup = requires.fix('permits').setup;
  createUser = requires.fac('create-user');
  createRequest = requires.fac('create-request');
  createPermit = requires.fac('create-permit');
  describe('PermitMatcher', function(){
    var permitMatcher, book, users, permits, requests, matching, noneMatching;
    users = {};
    permits = {};
    requests = {};
    matching = {};
    noneMatching = {};
    before(function(){
      users.kris = createUser.kris;
      requests.user = {
        user: users.kris
      };
      permits.user = setup.userPermit();
      return permitMatcher = new PermitMatcher(permits.user, requests.user);
    });
    describe('include', function(){
      describe('includes user.name: kris', function(){
        before(function(){
          return permits.user.includes = {
            user: users.kris
          };
        });
        return specify('matches access-request on includes intersect', function(){
          return permitMatcher.include().should.be['true'];
        });
      });
      describe('includes empty {}', function(){
        before(function(){
          return permits.user.includes = {};
        });
        return specify('matches access-request since empty includes always intersect', function(){
          return permitMatcher.include().should.be['true'];
        });
      });
      return describe('includes is nil', function(){
        before(function(){
          return permits.user.includes = void 8;
        });
        return specify('does NOT match access-request since NO includes intersect', function(){
          return permitMatcher.include().should.be['false'];
        });
      });
    });
    return describe('custom-match', function(){
      var subject, permitMatcher, book, users, permits, requests, matching, noneMatching;
      users = {};
      permits = {};
      requests = {};
      matching = {};
      noneMatching = {};
      before(function(){
        book = new Book({
          title: 'far and away'
        });
        requests.subject = {
          user: {},
          subject: book
        };
        requests.ctx = {
          ctx: void 8
        };
        permits.book = setup.bookPermit();
        matching.permitMatcher = new PermitMatcher(permits.book, requests.subject);
        return noneMatching.permitMatcher = new PermitMatcher(permits.book, requests.ctx);
      });
      context('matching permit-matcher', function(){
        before(function(){
          return subject = matching.permitMatcher;
        });
        specify('has permit', function(){
          return subject.permit.should.eql(permits.book);
        });
        return specify('has subject access-request', function(){
          return subject.accessRequest.should.eql(requests.subject);
        });
      });
      context('matching permit-matcher', function(){
        before(function(){
          return subject = noneMatching.permitMatcher;
        });
        specify('has permit', function(){
          return subject.permit.should.eql(permits.book);
        });
        return specify('has access-request', function(){
          return subject.accessRequest.should.eql(requests.ctx);
        });
      });
      specify('matches access-request using permit.match', function(){
        return matching.permitMatcher.customMatch().should.be['true'];
      });
      specify('does NOT match access-request since permit.match does NOT match', function(){
        return noneMatching.permitMatcher.customMatch().should.be['false'];
      });
      return describe('invalid match method', function(){
        before(function(){
          return permits.user = setup.invalidUser();
        });
        return specify('should throw error', function(){
          return function(){
            return noneMatching.permitMatcher.customMatch;
          }.should['throw'];
        });
      });
    });
  });
}).call(this);
