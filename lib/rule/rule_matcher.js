// Generated by LiveScript 1.2.0
(function(){
  var util, every, Debugger, RuleMatcher, toString$ = {}.toString;
  util = require('../util');
  every = util.array.every;
  Debugger = util.Debugger;
  module.exports = RuleMatcher = (function(){
    RuleMatcher.displayName = 'RuleMatcher';
    var prototype = RuleMatcher.prototype, constructor = RuleMatcher;
    importAll$(prototype, arguments[0]);
    function RuleMatcher(act, accessRequest){
      this.act = act;
      this.accessRequest = accessRequest;
      this.act = camelCase(this.act);
    }
    prototype.match = function(){
      var action, subject, subjClazz, actionSubjects;
      this.debug('match-rule', this.act, this.accessRequest);
      action = this.accessRequest.action;
      subject = this.accessRequest.subject;
      this.debug('action, subject', action, subject);
      subjClazz = this.subjectClazz(subject);
      this.debug('rule-container', this.ruleContainer());
      if (action === 'manage') {
        this.matchManageRule(this.ruleContainer(), subjClazz);
      }
      this.debug('subj-clazz', subjClazz);
      if (!subjClazz) {
        return false;
      }
      actionSubjects = this.ruleContainer()[action];
      this.debug('action-subjects', actionSubjects);
      if (!actionSubjects) {
        return false;
      }
      return this.matchSubjectClazz(actionSubjects, subjClazz);
    };
    prototype.containerFor = function(act){
      var c;
      act = act.toLowerCase();
      c = this[act + "Rules"];
      if (toString$.call(c).slice(8, -1) !== 'Object') {
        throw Error("No valid rule container for: " + act);
      }
      return c;
    };
    prototype.ruleContainer = function(){
      return this._container || (this._container = this.containerFor(this.act));
    };
    prototype.matchSubjectClazz = function(actionSubjects, subjClazz){
      this.debug('match-subject-clazz', actionSubjects, subjClazz);
      if (toString$.call(actionSubjects).slice(8, -1) !== 'Array') {
        return false;
      }
      return this.findMatchingSubject(actionSubjects, subjClazz);
    };
    prototype.wildcards = ['*', 'any'];
    prototype.subjectClazz = function(subject){
      var subjectClazz;
      if (toString$.call(subject).slice(8, -1) === 'Object') {
        return subjectClazz = subject.constructor.displayName;
      } else {
        return subjectClazz = subject;
      }
    };
    prototype.findMatchingSubject = function(subjects, subject){
      var self, camelized;
      if (contains(this.wildcards, subject)) {
        return true;
      }
      if (toString$.call(subject).slice(8, -1) === 'Array') {
        self = this;
        return contains(subjects, subject);
      }
      if (toString$.call(subject).slice(8, -1) !== 'String') {
        throw Error("find-matching-subject: Subject must be a String to be matched, was " + subject);
      }
      camelized = camelCase(subject);
      return subjects.indexOf(camelized) !== -1;
    };
    prototype.matchManageRule = function(ruleContainer, subjClazz){
      var manageSubjects, found;
      manageSubjects = ruleContainer['manage'];
      found = matchSubjectClazz(manageSubjects, subjClazz);
      if (found) {
        return found;
      }
      return every(manageActionSubjects(ruleContainer), function(actionSubjects){
        return matchSubjectClazz(actionSubjects, subjClazz);
      });
    };
    prototype.manageActionSubjects = function(ruleContainer){
      return this.manageActions.map(function(action){
        return ruleContainer[action];
      });
    };
    prototype.manageActions = ['create', 'edit', 'delete'];
    return RuleMatcher;
  }(Debugger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
