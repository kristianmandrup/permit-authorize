// Generated by LiveScript 1.2.0
(function(){
  var Debugger, util, RulesAccessor, delegate, i$, ref$, len$, name, toString$ = {}.toString;
  Debugger = require('../util').Debugger;
  util = require('./util');
  module.exports = RulesAccessor = (function(){
    RulesAccessor.displayName = 'RulesAccessor';
    var prototype = RulesAccessor.prototype, constructor = RulesAccessor;
    importAll$(prototype, arguments[0]);
    function RulesAccessor(permit, accessRequest, debugging){
      this.permit = permit;
      this.accessRequest = accessRequest;
      this.debugging = debugging;
      this.rules = this.permit.rules;
      this.ruleRepo = this.permit.ruleRepo;
      if (toString$.call(this.repo).slice(8, -1) !== 'Object') {
        throw Error("RuleApplier must be passed a RuleRepo, was: " + this.repo);
      }
      if (!util.validRules(this.rules)) {
        throw Error("RuleApplier must be passed the rules to be applied, was: " + this.rules);
      }
      if (!(this.accessRequest === undefined || toString$.call(this.accessRequest).slice(8, -1) === 'Object')) {
        throw Error("AccessRequest must be an Object, was: " + this.accessRequest);
      }
      this.debugging = this.debugging;
    }
    prototype.contextRules = function(context){
      if (toString$.call(context).slice(8, -1) === 'Object') {
        return context;
      }
      if (toString$.call(context).slice(8, -1) !== 'String') {
        return this.rules;
      }
      if (toString$.call(this.rules[context]).slice(8, -1) === 'Object') {
        return this.rules[context];
      } else {
        this.debug("no such rules context: " + context, this.rules);
        return this.rules;
      }
    };
    prototype.validRequest = function(){
      if (!this.accessRequest) {
        return false;
      }
      if (Object.keys(this.accessRequest).length > 0) {
        return true;
      } else {
        return false;
      }
    };
    prototype.ucan = function(actions, subjects, ctx){
      return this.repo.registerRule('can', actions, subjects, ctx);
    };
    prototype.ucannot = function(actions, subjects, ctx){
      return this.repo.registerRule('cannot', actions, subjects, ctx);
    };
    return RulesAccessor;
  }(Debugger));
  /*
    action: ->
      @access-request?.action
  
    user: ->
      @access-request?.user
  
    subject: ->
      @access-request?.subject
  
    ctx: ->
      @access-request?.ctx
  */
  delegate = function(obj, name, source){
    return obj[name] = function(){
      if (this.source) {
        return this[source][name];
      }
    };
  };
  for (i$ = 0, len$ = (ref$ = ['action', 'user', 'subject', 'ctx']).length; i$ < len$; ++i$) {
    name = ref$[i$];
    delegate(RulesAccessor, 'accessRequest', name);
  }
  /*
    can-rules: ->
      @repo.can-rules
  
    cannot-rules: ->
      @repo.cannot-rules
  */
  for (i$ = 0, len$ = (ref$ = ['canRules', 'cannotRules']).length; i$ < len$; ++i$) {
    name = ref$[i$];
    delegate(RulesAccessor, 'repo', name);
  }
  import$(RulesAccessor, Debugger);
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
