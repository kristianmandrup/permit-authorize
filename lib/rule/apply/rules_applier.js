// Generated by LiveScript 1.2.0
(function(){
  var util, utily, subject, Debugger, ExecutionContext, inspect, RulesApplier, toString$ = {}.toString;
  util = require('../util');
  utily = require('../../util');
  subject = utily.subject;
  Debugger = utily.Debugger;
  ExecutionContext = require('./execution_context');
  inspect = require('util').inspect;
  module.exports = RulesApplier = (function(){
    RulesApplier.displayName = 'RulesApplier';
    var prototype = RulesApplier.prototype, constructor = RulesApplier;
    importAll$(prototype, arguments[0]);
    function RulesApplier(executionContext, rules, debugging){
      this.executionContext = executionContext;
      this.rules = rules;
      this.debugging = debugging;
      this._validate();
      this;
    }
    prototype._validate = function(){
      if (!(this.executionContext.ucan && this.executionContext.ucannot)) {
        throw Error("Execution context must have ucan and ucannot methods for executing rules, was: " + inspect(this.executionContext));
      }
    };
    prototype.repo = function(){
      return this.executionContext.repo;
    };
    prototype.applyRulesFor = function(name, context){
      var rules, namedRules;
      if (toString$.call(name).slice(8, -1) !== 'String') {
        this.debug("Name to apply rules for must be a String, was: " + typeof name + " : " + name);
        return this;
      }
      this.debug("apply rules for " + name + " in context:", context);
      if (toString$.call(name).slice(8, -1) === 'Object') {
        this.applyObjRulesFor(name, context);
      }
      rules = this.contextRules(context);
      namedRules = rules[name];
      this.debug('named rules', namedRules);
      if (toString$.call(namedRules).slice(8, -1) === 'Function') {
        this.debug('call rules in', this.executionContext, this.executionContext.constructor.displayName);
        namedRules.call(this.executionContext, this.accessRequest);
      } else {
        this.debug("rules key for " + name + " should be a function that resolves one or more rules");
      }
      return this;
    };
    prototype.contextRules = function(name){
      this.debug('context rules', name);
      if (toString$.call(name).slice(8, -1) === 'Object') {
        return name;
      }
      if (toString$.call(name).slice(8, -1) !== 'String') {
        return this.rules;
      }
      if (toString$.call(this.rules[name]).slice(8, -1) === 'Object') {
        return this.rules[name];
      } else {
        this.debug("no such rules context: " + name, this.rules);
        return this.rules;
      }
    };
    prototype.applyObjRulesFor = function(object, context){
      var rules, objKeys, isUser, i$, len$, key, value, results$ = [];
      rules = this.contextRules(context);
      this.debug('apply-obj-rules-for object:', object, 'context:', context, 'rules:', rules);
      objKeys = Object.keys(object);
      isUser = subject(object).clazz === 'User';
      this.debug('obj-keys', objKeys, 'is user', isUser);
      if (isUser) {
        objKeys = ['name', 'role'];
      }
      for (i$ = 0, len$ = objKeys.length; i$ < len$; ++i$) {
        key = objKeys[i$];
        value = object[key];
        this.debug('object value', value, 'for', key);
        context = isUser
          ? context
          : rules[key];
        results$.push(this.applyRulesFor(value, context));
      }
      return results$;
    };
    prototype.applyAllRules = function(){
      var rules, key, results$ = [];
      switch (typeof this.rules) {
      case 'object':
        rules = this.rules;
        for (key in rules) {
          results$.push(util.recurse(rules[key], this.executionContext));
        }
        return results$;
        break;
      default:
        throw Error("rules must be an Object was: " + typeof this.rules);
      }
    };
    return RulesApplier;
  }(Debugger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
