// Generated by LiveScript 1.2.0
(function(){
  var requires, _, lo, util, normalize, Debugger, RuleRepo, toString$ = {}.toString;
  requires = require('../../requires');
  _ = require('prelude-ls');
  lo = require('lodash');
  require('sugar');
  util = require('util');
  normalize = requires.util('normalize');
  Debugger = requires.lib('debugger');
  module.exports = RuleRepo = (function(){
    RuleRepo.displayName = 'RuleRepo';
    var prototype = RuleRepo.prototype, constructor = RuleRepo;
    importAll$(prototype, arguments[0]);
    function RuleRepo(name){
      this.name = name;
    }
    prototype.canRules = {};
    prototype.cannotRules = {};
    prototype.display = function(){
      console.log("name:", this.name);
      console.log("can-rules:", this.canRules);
      return console.log("cannot-rules:", this.cannotRules);
    };
    prototype.cleanAll = function(){
      this.clean('can');
      this.clean('cannot');
      return this;
    };
    prototype.clean = function(act){
      if (act === undefined) {
        return this.cleanAll();
      }
      if (!(act === 'can' || act === 'cannot')) {
        throw Error("Repo can only clear 'can' or 'cannot' rules, was: " + act);
      }
      this.debug('clean', act);
      this[act + "Rules"] = {};
      return this;
    };
    prototype.clearAll = function(){
      return this.cleanAll();
    };
    prototype.clear = function(act){
      return this.clean(act);
    };
    prototype.subjectClazz = function(subject){
      var subjectClazz;
      if (_.isType('Object', subject)) {
        return subjectClazz = subject.constructor.displayName;
      } else {
        return subjectClazz = subject;
      }
    };
    prototype.findMatchingSubject = function(subjects, subject){
      var self, camelized;
      if (['*', 'any'].any(function(wildcard){
        return subjects.indexOf(wildcard) !== -1;
      })) {
        return true;
      }
      if (toString$.call(subject).slice(8, -1) === 'Array') {
        self = this;
        return subject.find(function(subj){
          return self.findMatchingSubject(subjects, subj);
        });
      }
      if (!_.isType('String', subject)) {
        throw Error("find-matching-subject: Subject must be a String to be matched, was " + util.inspect(subject));
      }
      camelized = subject != null ? subject.camelize(true) : void 8;
      return subjects.indexOf(camelized) !== -1;
    };
    prototype.matchRule = function(act, accessRequest){
      var action, subject, subjClazz, ruleContainer, actionSubjects;
      this.debug('match-rule', act, accessRequest);
      act = act.camelize(true);
      action = accessRequest.action;
      subject = accessRequest.subject;
      subjClazz = this.subjectClazz(subject);
      ruleContainer = this.containerFor(act);
      if (action === 'manage') {
        this.matchManageRule(ruleContainer, subjClazz);
      }
      this.debug('subj-clazz', subjClazz);
      if (!subjClazz) {
        return;
      }
      actionSubjects = ruleContainer[action];
      if (!actionSubjects) {
        return;
      }
      return this.matchSubjectClazz(actionSubjects, subjClazz);
    };
    prototype.matchSubjectClazz = function(actionSubjects, subjClazz){
      this.debug('match-subject-clazz', actionSubjects, subjClazz);
      if (!_.isType('Array', actionSubjects)) {
        return false;
      }
      return this.findMatchingSubject(actionSubjects, subjClazz);
    };
    prototype.matchManageRule = function(ruleContainer, subjClazz){
      var manageSubjects, found;
      manageSubjects = ruleContainer['manage'];
      found = matchSubjectClazz(manageSubjects, subjClazz);
      if (found) {
        return found;
      }
      return manageActionSubjects(ruleContainer).all(function(actionSubjects){
        return matchSubjectClazz(actionSubjects, subjClazz);
      });
    };
    prototype.manageActionSubjects = function(ruleContainer){
      return ['create', 'edit', 'delete'].map(function(action){
        return ruleContainer[action];
      });
    };
    prototype.addRule = function(ruleContainer, action, subjects){
      var ruleSubjects, uniqueSubjects, actionSubjects, self;
      if (!_.isType('Object', ruleContainer)) {
        throw Error("Container must be an object");
      }
      ruleSubjects = ruleContainer[action] || [];
      subjects = normalize(subjects);
      ruleSubjects = ruleSubjects.concat(subjects);
      ruleSubjects = ruleSubjects.map(function(subject){
        var val;
        val = subject.camelize(true);
        if (val === 'Any') {
          return '*';
        } else {
          return val;
        }
      });
      uniqueSubjects = _.unique(ruleSubjects);
      actionSubjects = ruleContainer[action];
      if (!_.isType('Array', actionSubjects)) {
        actionSubjects = [];
      }
      ruleContainer[action] = this.registerActionSubjects(actionSubjects, uniqueSubjects);
      if (action === 'manage') {
        self = this;
        return ['create', 'edit', 'delete'].each(function(action){
          return ruleContainer[action] = self.registerActionSubjects(actionSubjects, uniqueSubjects);
        });
      }
    };
    prototype.registerActionSubjects = function(actionContainer, subjects){
      return actionContainer.concat(subjects).unique();
    };
    prototype.containerFor = function(act){
      var c;
      act = act.toLowerCase();
      c = this[act + "Rules"];
      if (!_.isType('Object', c)) {
        throw Error("No valid rule container for: " + act);
      }
      return c;
    };
    prototype.registerRule = function(act, actions, subjects){
      var ruleContainer, i$, len$, action, results$ = [];
      actions = normalize(actions);
      ruleContainer = this.containerFor(act);
      for (i$ = 0, len$ = actions.length; i$ < len$; ++i$) {
        action = actions[i$];
        results$.push(this.addRule(ruleContainer, action, subjects));
      }
      return results$;
    };
    return RuleRepo;
  }(Debugger));
  lo.extend(RuleRepo, Debugger);
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
