// Generated by LiveScript 1.2.0
(function(){
  var requires, lo, PermitRegistry, PermitMatcher, PermitAllower, RuleApplier, RuleRepo, matchers, UserMatcher, SubjectMatcher, ActionMatcher, ContextMatcher, AccessMatcher, Debugger, Permit, toString$ = {}.toString;
  requires = require('../requires');
  lo = requires.util('lodash-lite');
  PermitRegistry = requires.permit('permit_registry');
  PermitMatcher = requires.permit('permit_matcher');
  PermitAllower = requires.permit('permit_allower');
  RuleApplier = requires.rule('rule_applier');
  RuleRepo = requires.rule('rule_repo');
  matchers = requires.lib('matchers');
  UserMatcher = matchers.UserMatcher;
  SubjectMatcher = matchers.SubjectMatcher;
  ActionMatcher = matchers.ActionMatcher;
  ContextMatcher = matchers.ContextMatcher;
  AccessMatcher = matchers.AccessMatcher;
  Debugger = requires.lib('debugger');
  module.exports = Permit = (function(){
    Permit.displayName = 'Permit';
    var prototype = Permit.prototype, constructor = Permit;
    importAll$(prototype, arguments[0]);
    function Permit(name, description){
      this.name = name;
      this.description = description != null ? description : '';
      PermitRegistry.registerPermit(this);
      this.ruleRepo = new RuleRepo(this.name);
      this.appliedRules = false;
      this;
    }
    prototype.permitMatcherClass = PermitMatcher;
    prototype.ruleApplierClass = RuleApplier;
    Permit.get = function(name){
      return PermitRegistry.get(name);
    };
    prototype.init = function(){
      this.debug('permit init');
      this.applyRules();
      this.configureMatchers();
      return this;
    };
    prototype.configureMatchers = function(){
      var key;
      this.debug("configure-matchers", this.matchesOn);
      if (toString$.call(this.matchesOn).slice(8, -1) !== 'Object') {
        return;
      }
      this.compiledList = [];
      this.debug("compile...");
      for (key in this.matchesOn) {
        this.compileFor(key, this.matchesOn[key]);
      }
      return this.debug('compiled matchers:', this.compiledList);
    };
    prototype.compileFor = function(key, list){
      var fun;
      this.debug("compile for", key, list);
      fun = this.compiledMatcher(key, list);
      this.debug('fun', fun);
      return this.compiledList.push(fun);
    };
    prototype.compiledMatcher = function(type, matchList){
      var self;
      self = this;
      return function(accessRequest){
        var matchObj, ref$;
        matchObj = (ref$ = {}, ref$[type] = matchList, ref$);
        self.debug('compiled fun: match-on', accessRequest);
        return self.matchOn(accessRequest, matchObj);
      };
    };
    prototype.clean = function(){
      this.ruleRepo.clean();
      return this.appliedRules = false;
    };
    prototype.use = function(obj){
      if (toString$.call(obj).slice(8, -1) === 'Function') {
        obj = obj();
      }
      if (toString$.call(obj).slice(8, -1) === 'Object') {
        return lo.extend(this, obj);
      } else {
        throw Error("Can only extend permit with an Object, was: " + toString$.call(obj).slice(8, -1));
      }
    };
    prototype.rules = function(){};
    prototype.permitAllower = function(){
      return new PermitAllower(this.ruleRepo, this.debugging);
    };
    prototype.allows = function(accessRequest){
      var res;
      this.debug('permit allows?', this.name, this.description);
      res = this.permitAllower().allows(accessRequest);
      this.debug(this.name + " Permit allows:", this.rules, accessRequest, res);
      return res;
    };
    prototype.disallows = function(accessRequest){
      var res;
      this.debug('permit disallows?', this.name, this.description);
      res = this.permitAllower().disallows(accessRequest);
      this.debug(this.name + " Permit disallows:", this.rules, accessRequest, res);
      return res;
    };
    prototype.matching = function(access){
      return new AccessMatcher(access);
    };
    prototype.matcher = function(accessRequest){
      return new this.permitMatcherClass(this, accessRequest, this.debugging);
    };
    prototype.matches = function(accessRequest){
      var permitMatcher;
      this.debug('matches', accessRequest);
      permitMatcher = this.matcher(accessRequest);
      this.debug('permit matcher', permitMatcher);
      return permitMatcher.match();
    };
    prototype.matchOn = function(accessRequest, matchObj){
      return this.matching(accessRequest).matchOn(matchObj);
    };
    prototype.matchUser = function(accessRequest, user){
      return this.matching(accessRequest).user(user);
    };
    prototype.matchRole = function(accessRequest, role){
      return this.matching(accessRequest).role(role);
    };
    prototype.matchSubject = function(accessRequest, subj){
      return this.matching(accessRequest).subject(subj);
    };
    prototype.matchSubjectClazz = function(clazz){
      return {
        subjectClazz: this.matching(accessRequest).clazz
      };
    };
    prototype.matchAction = function(action){
      return this.matching(accessRequest).action(action);
    };
    prototype.matchContext = function(ctx){
      return this.matches(accessRequest).context(ctx);
    };
    prototype.matchCtx = function(ctx){
      return this.matching(accessRequest).ctx(ctx);
    };
    prototype.ruleApplier = function(accessRequest){
      if (toString$.call(accessRequest).slice(8, -1) !== 'Object') {
        accessRequest = {};
      }
      return new this.ruleApplierClass(this.ruleRepo, this.rules, accessRequest, this.debugging);
    };
    prototype.applyRules = function(accessRequest, force){
      if (!(accessRequest === undefined || toString$.call(accessRequest).slice(8, -1) === 'Object')) {
        force = Boolean(accessRequest);
      }
      if (!(this.appliedRules && !force)) {
        this.debug('permit apply rules', accessRequest);
        this.ruleApplier(accessRequest).applyRules();
        return this.appliedRules = true;
      } else {
        return this.debug('rules already applied before', this.appliedRules);
      }
    };
    prototype.canRules = function(){
      return this.ruleRepo.canRules;
    };
    prototype.cannotRules = function(){
      return this.ruleRepo.cannotRules;
    };
    return Permit;
  }(Debugger));
  lo.extend(Permit, Debugger);
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
