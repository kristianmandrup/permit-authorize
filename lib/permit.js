// Generated by LiveScript 1.2.0
(function(){
  var requires, lo, PermitRegistry, PermitMatcher, PermitAllower, RuleApplier, RuleRepo, matchers, UserMatcher, SubjectMatcher, ActionMatcher, ContextMatcher, AccessMatcher, Util, Debugger, Permit;
  requires = require('../requires');
  lo = require('lodash');
  PermitRegistry = requires.permit('permit_registry');
  PermitMatcher = requires.permit('permit_matcher');
  PermitAllower = requires.permit('permit_allower');
  RuleApplier = requires.rule('rule_applier');
  RuleRepo = requires.rule('rule_repo');
  matchers = requires.lib('matchers');
  UserMatcher = matchers.UserMatcher;
  SubjectMatcher = matchers.SubjectMatcher;
  ActionMatcher = matchers.ActionMatcher;
  ContextMatcher = matchers.ContextMatcher;
  AccessMatcher = matchers.AccessMatcher;
  Util = requires.lib('util');
  Debugger = requires.lib('debugger');
  module.exports = Permit = (function(){
    Permit.displayName = 'Permit';
    var prototype = Permit.prototype, constructor = Permit;
    importAll$(prototype, arguments[0]);
    function Permit(name, description){
      this.name = name;
      this.description = description != null ? description : '';
      PermitRegistry.registerPermit(this);
      this.ruleRepo = new RuleRepo(this.name);
      this.appliedRules = false;
      this;
    }
    prototype.permitMatcherClass = PermitMatcher;
    prototype.ruleApplierClass = RuleApplier;
    Permit.get = function(name){
      return PermitRegistry.get(name);
    };
    prototype.init = function(){
      this.applyRules();
      return this;
    };
    prototype.clean = function(){
      this.ruleRepo.clean();
      return this.appliedRules = false;
    };
    prototype.use = function(obj){
      if (_.isType('Function', obj)) {
        obj = obj();
      }
      if (_.isType('Object', obj)) {
        return lo.extend(this, obj);
      } else {
        throw Error("Can only extend permit with an Object, was: " + typeof obj);
      }
    };
    prototype.rules = function(){};
    prototype.permitAllower = function(){
      return new PermitAllower(this.ruleRepo, this.debugging);
    };
    prototype.allows = function(accessRequest){
      var res;
      this.debug('permit allows?', this.name, this.description);
      res = this.permitAllower().allows(accessRequest);
      this.debug(this.name + " Permit allows:", this.rules, accessRequest, res);
      return res;
    };
    prototype.disallows = function(accessRequest){
      var res;
      this.debug('permit disallows?', this.name, this.description);
      res = this.permitAllower().disallows(accessRequest);
      this.debug(this.name + " Permit disallows:", this.rules, accessRequest, res);
      return res;
    };
    prototype.matching = function(access){
      return new AccessMatcher(access);
    };
    prototype.matcher = function(accessRequest){
      return new this.permitMatcherClass(this, accessRequest, this.debugging);
    };
    prototype.matches = function(accessRequest){
      this.debug('matches', accessRequest);
      return this.matcher(accessRequest).match();
    };
    prototype.ruleApplier = function(accessRequest){
      if (!_.isType('Object', accessRequest)) {
        accessRequest = {};
      }
      return new this.ruleApplierClass(this.ruleRepo, this.rules, accessRequest, this.debugging);
    };
    prototype.applyRules = function(accessRequest, force){
      if (!(accessRequest === undefined || _.isType('Object', accessRequest))) {
        force = Boolean(accessRequest);
      }
      if (!(this.appliedRules && !force)) {
        this.debug('permit apply rules', accessRequest);
        this.ruleApplier(accessRequest).applyRules();
        return this.appliedRules = true;
      } else {
        return this.debug('rules already applied before', this.appliedRules);
      }
    };
    prototype.canRules = function(){
      return this.ruleRepo.canRules;
    };
    prototype.cannotRules = function(){
      return this.ruleRepo.cannotRules;
    };
    return Permit;
  }(Debugger));
  lo.extend(Permit, Debugger);
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
