// Generated by LiveScript 1.2.0
(function(){
  var requires, lo, fs, Debugger, permitFor, PermitRulesLoader, toString$ = {}.toString;
  requires = require('../../requires');
  lo = requires.util('lodash-lite');
  fs = require('fs');
  Array.prototype.contains = function(v){
    return this.indexOf(v) > -1;
  };
  Debugger = requires.lib('debugger');
  permitFor = requires.permit('permit-for');
  PermitRulesLoader = (function(){
    PermitRulesLoader.displayName = 'PermitRulesLoader';
    var prototype = PermitRulesLoader.prototype, constructor = PermitRulesLoader;
    importAll$(prototype, arguments[0]);
    function PermitRulesLoader(filePath, options){
      this.filePath = filePath;
      this.options = options != null
        ? options
        : {};
      this.loadedRules = {};
      this.async = this.options.async;
    }
    prototype.createPermit = function(name, baseClazz){
      var loadedRules;
      baseClazz || (baseClazz = requires.lib('permit'));
      loadedRules = this.loadRules().rules();
      console.log('loaded-rules', loadedRules, this.filePath);
      return permitFor(baseClazz, name, function(){
        return {
          rules: loadedRules
        };
      });
    };
    prototype.loadRules = function(filePath, async){
      this.filePath || (this.filePath = filePath);
      if (async !== void 8) {
        this.async = async;
      } else {
        this.async || (this.async = true);
      }
      this.debug("loadRules", this.filePath);
      if (!this.filePath) {
        throw Error("Error: Missing filepath");
      }
      if (this.async) {
        return this.loadRulesAsync(filePath);
      } else {
        return this.loadRulesSync(filePath);
      }
    };
    prototype.loadRulesAsync = function(){
      var self;
      this.debug('loadRulesAsync');
      self = this;
      fs.readFile(this.filePath, 'utf8', function(err, data){
        var rules;
        self.debug(err, data);
        if (err) {
          this.debug(err);
          throw Error("Error loading file: " + this.filePath + " - " + err);
        }
        self.debug("data", data);
        rules = JSON.parse(data);
        self.debug("loaded-rules", rules);
        self.loadedRules = rules;
        return self.processRules();
      });
      return this;
    };
    prototype.loadRulesSync = function(){
      var data, rules, err;
      try {
        data = fs.readFileSync(this.filePath, 'utf8', function(){});
        this.debug("data", data);
        if (toString$.call(data).slice(8, -1) !== 'String') {
          throw Error;
        }
        rules = JSON.parse(data);
        this.debug("loaded-rules", rules);
        this.loadedRules = rules;
        this.processRules();
        return this;
      } catch (e$) {
        err = e$;
        throw Error("Error loading file: " + this.filePath + " - " + err);
      }
    };
    prototype.loadRulesFrom = function(path){
      return this.loadRules(path);
    };
    prototype.load = function(path){
      return this.loadRules(path);
    };
    prototype.processRules = function(){
      var key, ref$, rule;
      this.debug("processRules", this.loadedRules);
      if (toString$.call(this.loadedRules).slice(8, -1) !== 'Object') {
        throw Error("Rules not loaded or invalid: " + this.loadedRules);
      }
      this.processedRules = {};
      for (key in ref$ = this.loadedRules) {
        rule = ref$[key];
        this.processRule(key, rule);
      }
      return this.processedRules;
    };
    prototype.processRule = function(key, rule){
      this.debug("processRule", key, rule);
      return this.processedRules[key] = this.ruleFor(rule);
    };
    prototype.createRulesAt = function(permit, place){
      if (toString$.call(permit).slice(8, -1) !== 'Function') {
        throw Error("Not a permit, was: " + permit);
      }
      if (place != null) {
        if (!(permit.rules != null && toString$.call(permit.rules).slice(8, -1) === 'Object')) {
          throw Error("Permit has no rules object to place loaded rules at " + place);
        }
        return permit.rules[place] = this.processedRules;
      } else {
        return permit.rules = this.processedRules;
      }
    };
    prototype.rules = function(){
      return this.processedRules;
    };
    prototype.ruleFor = function(rule){
      var key;
      this.debug("ruleFor", rule);
      key = Object.keys(rule)[0];
      if (!['can', 'cannot'].contains(key)) {
        throw Error("Not a valid rule key, must be 'can' or 'cannot', was: " + key);
      }
      return this.factory(key, rule[key]);
    };
    prototype.factory = function(act, rule){
      var rules, action, subject, fun;
      rules = [];
      for (action in rule) {
        subject = rule[action];
        fun = this.resolve(act, action, subject);
        rules.push(fun);
      }
      return function(){
        var i$, ref$, len$, rule, results$ = [];
        for (i$ = 0, len$ = (ref$ = rules).length; i$ < len$; ++i$) {
          rule = ref$[i$];
          results$.push(this.rule());
        }
        return results$;
      };
    };
    prototype.resolve = function(act, action, subject){
      return function(){
        return this["u" + act](action, subject);
      };
    };
    return PermitRulesLoader;
  }(Debugger));
  module.exports = PermitRulesLoader;
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
