// Generated by LiveScript 1.2.0
(function(){
  var Debugger, ContextMatcher, toString$ = {}.toString;
  Debugger = require('../../util').Debugger;
  module.exports = ContextMatcher = (function(){
    ContextMatcher.displayName = 'ContextMatcher';
    var prototype = ContextMatcher.prototype, constructor = ContextMatcher;
    importAll$(prototype, arguments[0]);
    function ContextMatcher(context, key, accessRequest, debugging){
      this.context = context;
      this.key = key;
      this.accessRequest = accessRequest;
      this.debugging = debugging;
      console.log('ContextMatcher', this);
      this.validate();
      if (this.context.matches) {
        this.context = this.context.matches;
      }
      this;
    }
    prototype.validate = function(){
      if (toString$.call(this.context).slice(8, -1) !== 'Object') {
        throw new Error("context must be an Object, was: " + this.context);
      }
      if (toString$.call(this.key).slice(8, -1) !== 'String') {
        throw new Error("Key must be a String, was: " + this.key);
      }
      if (toString$.call(this.accessRequest).slice(8, -1) !== 'Object') {
        throw new Error("access-request must be an Object, was: " + this.accessRequest);
      }
    };
    prototype.matchingContext = function(){
      return new (require('./matching_context'))(this.context, this.accessRequest);
    };
    prototype.match = function(){
      return this.intersect() || this.fun() || this.none();
    };
    prototype.none = function(){
      return false;
    };
    prototype.intersect = function(){
      if (!this.context.intersect) {
        return false;
      }
      return this.intersectOn(this.accessRequest);
    };
    prototype.fun = function(){
      var res;
      this.debug('fun context', this.context);
      if (!this.context.fun) {
        return false;
      }
      this.matchFun = this.context.fun[this.key] || this.context.fun;
      this.debug('match fun', this.matchFun);
      if (toString$.call(this.matchFun).slice(8, -1) !== 'Function') {
        return false;
      }
      this.debug('fun', this.matchFun, this.accessRequest);
      res = this.matchFun.call(this.matchingContext());
      if (toString$.call(res.result).slice(8, -1) === 'Function') {
        return res.result();
      }
      if (res === undefined) {
        return false;
      }
      if (toString$.call(res).slice(8, -1) !== 'Boolean') {
        throw Error(this.key + " method of context " + this.context.fun + " must return a Boolean value, was: " + toString$.call(res).slice(8, -1));
      }
      return res;
    };
    prototype.intersectContext = function(){
      return this._intersectContext || (this._intersectContext = this.context.intersect[this.key] || this.context.intersect);
    };
    prototype.intersectOn = function(partial){
      partial || (partial = this.accessRequest);
      this.debug('intersect.on', this.intersectContext(), partial);
      if (toString$.call(this.intersectContext()).slice(8, -1) !== 'Object') {
        return false;
      }
      if (toString$.call(partial).slice(8, -1) !== 'Object') {
        return false;
      }
      if (toString$.call(partial).slice(8, -1) === 'Function') {
        partial = partial();
      }
      this.debug('intersect partial:', partial);
      return this.intersector().on(this.intersectContext(), partial);
    };
    prototype.intersector = function(){
      return this._intersector || (this._intersector = require('../../util').Intersect());
    };
    return ContextMatcher;
  }(Debugger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
