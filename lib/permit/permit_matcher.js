// Generated by LiveScript 1.2.0
(function(){
  var requires, _, lo, Util, Intersect, AccessMatcher, Debugger, PermitMatcher;
  requires = require('../../requires');
  _ = require('prelude-ls');
  lo = require('lodash');
  require('sugar');
  Util = requires.lib('util');
  Intersect = requires.util('intersect');
  AccessMatcher = requires.lib('matchers').AccessMatcher;
  Debugger = requires.lib('debugger');
  module.exports = PermitMatcher = (function(){
    PermitMatcher.displayName = 'PermitMatcher';
    var prototype = PermitMatcher.prototype, constructor = PermitMatcher;
    importAll$(prototype, arguments[0]);
    function PermitMatcher(permit, accessRequest, debugging){
      this.permit = permit;
      this.accessRequest = accessRequest;
      this.debugging = debugging;
      this.intersect = Intersect();
      this.validate();
    }
    prototype.match = function(){
      return (this.include() || this.customMatch()) && !(this.exclude() || this.customExMatch());
    };
    prototype.include = function(){
      return this.intersectOn(this.permit.includes);
    };
    prototype.exclude = function(){
      return this.intersectOn(this.permit.excludes);
    };
    prototype.customExMatch = function(){
      var res;
      if (_.isType('Function', this.permit.exMatch)) {
        res = this.permit.exMatch(this.accessRequest);
        if (res.constructor === AccessMatcher) {
          return res.result();
        }
        if (res === undefined) {
          return true;
        }
        if (!_.isType('Boolean', res)) {
          throw Error(".match method of permit " + this.permit.name + " must return a Boolean value, was: " + typeof res);
        }
        return res;
      } else {
        this.debug("permit.ex-match function not found for permit: " + this.permit);
        return false;
      }
    };
    prototype.customMatch = function(){
      var res;
      if (_.isType('Function', this.permit.match)) {
        res = this.permit.match(this.accessRequest);
        this.debug('custom-match', this.permit.match, res);
        if (res.constructor === AccessMatcher) {
          return res.result();
        }
        if (res === undefined) {
          return true;
        }
        if (!_.isType('Boolean', res)) {
          throw Error(".match method of permit " + this.permit.name + " must return a Boolean value, was: " + typeof res);
        }
        return res;
      } else {
        this.debug("permit.match function not found for permit: " + this.permit);
        return false;
      }
    };
    prototype.intersectOn = function(partial){
      var res;
      if (partial == null) {
        return false;
      }
      if (_.isType('Function', partial)) {
        partial = partial();
      }
      res = this.intersect.on(partial, this.accessRequest);
      return res;
    };
    prototype.validate = function(){
      if (!this.permit) {
        throw Error("PermitMatcher missing permit");
      }
      if (this.accessRequest != null && this.accessRequest === undefined) {
        throw Error("access-request is undefined");
      }
    };
    return PermitMatcher;
  }(Debugger));
  lo.extend(PermitMatcher, Debugger);
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
